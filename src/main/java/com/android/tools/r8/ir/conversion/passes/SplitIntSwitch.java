// Copyright (c) 2025, the R8 project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

package com.android.tools.r8.ir.conversion.passes;

import com.android.tools.r8.graph.AppInfo;
import com.android.tools.r8.graph.AppView;
import com.android.tools.r8.ir.code.BasicBlock;
import com.android.tools.r8.ir.code.Goto;
import com.android.tools.r8.ir.code.IRCode;
import com.android.tools.r8.ir.code.IntSwitch;
import com.android.tools.r8.ir.code.Phi;
import com.android.tools.r8.ir.code.Value;
import com.android.tools.r8.ir.conversion.MethodProcessor;
import com.android.tools.r8.ir.conversion.passes.result.CodeRewriterResult;
import com.android.tools.r8.ir.optimize.AffectedValues;
import it.unimi.dsi.fastutil.ints.Int2ReferenceSortedMap;
import java.util.IdentityHashMap;
import java.util.Map;

public class SplitIntSwitch extends CodeRewriterPass<AppInfo> {

  protected SplitIntSwitch(AppView<?> appView) {
    super(appView);
  }

  @Override
  protected String getRewriterId() {
    return "SplitIntSwitch";
  }

  @Override
  protected boolean shouldRewriteCode(IRCode code, MethodProcessor methodProcessor) {
    return code.metadata().mayHaveIntSwitch() && code.getBlocks().size() >= 6;
  }

  /**
   * Simplifies intSwitch on a phi with only constant values. This has to support the pattern
   * generated by the jdk21 type and enum switches.
   */
  @Override
  protected CodeRewriterResult rewriteCode(IRCode code) {
    boolean changed = false;
    boolean lastChanged = true;
    while (lastChanged) {
      lastChanged = rewriteFirstIntSwitch(code);
      if (lastChanged) {
        AffectedValues values = code.removeUnreachableBlocks();
        assert values.isEmpty();
      }
      changed |= lastChanged;
    }
    if (changed) {
      code.removeRedundantBlocks();
    }
    return CodeRewriterResult.hasChanged(changed);
  }

  private boolean rewriteFirstIntSwitch(IRCode code) {
    for (BasicBlock block : code.blocks) {
      if (block.getLastInstruction().isIntSwitch()
          && block.getInstructions().size() == 1
          && block.getPhis().size() == 1
          && block.getLastInstruction().getFirstOperand() == block.getPhis().get(0)
          && block.getPhis().get(0).allOperandsMatch(Value::isConstInt)
          && block.getPhis().get(0).hasSingleUniqueUserAndNoOtherUsers()) {
        rewriteIntSwitch(block);
        return true;
      }
    }
    return false;
  }

  private void rewriteIntSwitch(BasicBlock block) {
    Phi phi = block.getPhis().get(0);
    IntSwitch intSwitch = block.getLastInstruction().asIntSwitch();
    Int2ReferenceSortedMap<BasicBlock> keyToTargetMap = intSwitch.getKeyToTargetMap();
    BasicBlock defaultTarget = intSwitch.fallthroughBlock();
    Map<Goto, BasicBlock> newTargets = new IdentityHashMap<>();
    for (int i = 0; i < phi.getOperands().size(); i++) {
      BasicBlock pred = block.getPredecessors().get(i);
      BasicBlock newTarget =
          keyToTargetMap.getOrDefault(phi.getOperand(i).getConstInt(), defaultTarget);
      assert pred.getLastInstruction().isGoto();
      newTargets.put(pred.getLastInstruction().asGoto(), newTarget);
    }
    retargetGotos(newTargets);
  }

  private void retargetGotos(Map<Goto, BasicBlock> newTargets) {
    newTargets.forEach(
        (goTo, newTarget) -> {
          BasicBlock initialTarget = goTo.getTarget();
          for (Phi phi : initialTarget.getPhis()) {
            int index = initialTarget.getPredecessors().indexOf(goTo.getBlock());
            phi.removeOperand(index);
          }
          goTo.setTarget(newTarget);
        });
  }
}
